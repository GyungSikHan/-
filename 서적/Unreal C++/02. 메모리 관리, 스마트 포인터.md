- 메모리 관리
    - Unreal의 UObject 참조 카운팅 시스템은 UObject로 파생된 액터와 클래스 메모리를 관리하는 기본적인 수단으로, 엔진 내에서 메모리가 관리된다
    - 하지만 UObject에서 파생되지 않은 커스텀 C++ 클래스들을 작성한다면 TSharedPtr/TWeakPtr을 사용해 참조 카운팅 클래스를 활용하면 되며, 참조가 없을시 자동으로 오브젝트를 삭제하여 Dangling Pointer를 만들지 않는다 
    - new, malloc 차이
        - malloc: 사용할 연속적 메모리 공간을 할당
        - new: 사용할 연속적 메모리 공간을 할당, 생성자를 new 연산자의 인수로 사용되는 오브젝트 타입으로 호출
    - Unreal 관리되는 메모리 - NewObject<>, ConstructObject<>
        - 이들은 오브젝트를 참조하는 포인터를 기억 후, 참조하는 포인터가 사라지면 자동으로 즉시 지워지거나, 표시 후 가비지 컬렉션에 의해 지워진다
        - Actor 클래스의 파생이 아닌 모든 UObject는 파생 오브젝트를 생성할 때 NewObject<>를 사용한다
        - 오브젝트가 Actor클래스 또는 그 파생 클래스는 SpawnActor<> 를 사용한다
        - NewObject<> 사용 예시 
            - UAction* test = NewObject<UAction>(GetTransientPackge(),UAction::StaticClass()/*RF_*플래그*/)
                - UAction::StaticClass()를 사용하면 UAction 오브젝트의 베이스인 UClass를 얻어올 수 있다
                - 첫 인자 GetTransientPackge()는 단순히 게임의 휘발성 패키지를 얻어오는데, Unreal에서 패키지는 단순한 데이터의 집합체이다
                - UClass 인스턴스를 선택하기 위해서는 블루프린트에서 UPROPERTY() TSubclassOf<AActor>를 사용할 수도 있다
                - 세번째 파라미터는 선택적인 값으로 메모리 관리 시스템이 어떤 방식으로 UObject를 다룰지 지정한다
            -  ConstructObject<>
                - NewObject와 유사하지만  함수 생성 시점에 좀더 많은 파라미터를 제공한다
                - 특정 속성을 초기화하고 싶다면 유용하지만 일반적으로 NewObject면 충분하다
            -  관리되는 메모리 해제
                - 일반적으로 UObject 인스턴스에 모든 참조가 사라지면 가비지 컬렉션 대상이 되어 삭제가 된다
                - 하지만 NewObject<>, ConstructObject<>를 사용한 UObject 클래스 파생 오브젝트도 참조 카운트가 0으로 떨어지기 전 UObject::ConditionalBeginDestroy()함수를 통해 메모리 해제가 가능한데 이때 반드시 사용하지 않는다는 확신이 존재하는 오브젝트들만 삭제해야 한다
        - 스마트 포인터(TSharedPtr, TWeakPtr, TAutoPtr)
            - 정의
                - 표준 C++ 오브젝트에 대한 delete 호출을 잊는것을 방지하기 위해 사용하게 되었다
                - TSharedPtr 클래스는 모든 커스텀 C++ 오브젝트를 UObject처럼 참조 카운팅 방식으로 만들어준다
                - TSharedPtr의 대체 클래스 TWrakPtr은 참조 카운트 오브젝트를 지원하지만 삭제를 방지할 수 없다는 특징이 있다
            - 원리
                - 원시 포인터를 사용하지 않고 UObject 파생이 아닌 오브젝트를 추적하고 삭제하는 상황에서는 TSharedPtr이나 TSharedRef를 사용한다
                - new 키워드를 사용해 동적할당 되는 오브젝트를 사용하면, 이를 참조 카운터를 지원하는 포인터로 감싸 자동적으로 메모리가 해제되게 할 수 있다
            - 종류
                - TSharedPtr
                    - 스레드로부터 안전한(두번째 파라미터가 ESPMode::ThreadSafe를 전달한 경우) 참조 카운트 포인터 타입으로 공유 오브젝트를 나타냄
                    - 공유 오브젝트는 더이상 참조가 없을경우 해제됨
                - TAutoPtr
                    - 스레드로부터 안전하지 않은 공유 포인터
            - 약한포인터(Weak Pointer)
                - 참조 카운트가 0으로 내려갈 때 오브젝트를 유지하는 기능이 없다
                - 약한 포인터 아래에 오브젝트를 수동으로 삭제할 때 약한 포인터 참조가 NULL이 된다
            - 공유포인터(Shared Pointer)
                - 스레드로부터 안전하다. 이는 기본 오브젝트를 별도의 스레드에서 안전하게 조작 가능하다는 의미이다
            - TSharedRef는 UObject 또는 그의 파생에는 사용 불가능하고 커스텀 C++ 클래스에서만 사용이 가능하다
            - TStructure는 TSharedPtr, TSharedRef, TWeakPtr 클래스를 사용해 원시 포인터를 감쌀 수 있다
            - TSharedPtr의 스레드 안정성을 보장하지 않아도 된다면 TAutoPtr을 사용할 수 있고 이는 참조의 수가 0으로 떨어지면 자동으로 오브젝트를 지운다
            - 오브젝트 추적을 위해 TScopedPointer 사용
                - 범위 포인터(Scoped Pointer)는 선언된 블록의 끝에서 자동 삭제되는 포인터이다
                - 이를 통해 사용하여 범위 포인터의 수명 기간 동안 참조 카운터 오브젝트를 유지하여 할당이 해제되지 않게 할 수 있다