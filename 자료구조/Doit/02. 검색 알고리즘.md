**검색 알고리즘이란?**

- 데이터 집합에서 우언하는 값을 가진 요소를 찾아내는 검색 알고리

![](https://blog.kakaocdn.net/dn/o1osz/btstSiEjRDt/8mTKfmLezxZR3cf7m9odS1/img.png)

- 검색 알고리즘 종류
    - 선형검색: 무작위로 늘어놓은 데이터 모임에서 검색을 수행
    - 이진검색: 일정한 규칙으로 늘어놓은 데이터 모임에서 아주 빠른 검색을 수행
    - 해시법: 추가, 삭제가 자주 일어나는 데이터 모임에서 아주 빠른 검색 수행
        - 체인법: 같은 해시값의 데이터를 선형 리스트로 연ㄴ결하는 방법
        - 오픈 주소법: 데이터를 위한 해식밧이 충돌할 때 재해시(rehasing) 하는 방법  
              
            

---

**선형 검색(Linear Search)**

- - 정의
        - 요소가 직선 모양으로 늘어선 배열에서의 원하는 키값을 갖는 요소를 만날 때 까지 맨 앞부터 순서대로 요소를 검색하는 것
        - 순차 검색(Sequential Search) 이라고도 함

![](https://blog.kakaocdn.net/dn/cjH5gy/btstRr2OJWh/QhRvuXl86jNtM60OVsKb30/img.png)

- 구현 방법  
    - 배열의 첫번째 주소부터 마지막까지 찾고자 하는 요소와 비교하여 찾는다
- 보초법
    - 기존 배열의 맨 마지막에 찾고자 하는 보초(요소)를 추가해준다
    - 배열의 첫번째 주소부터 보초가 있는 주소까지 반복문을 이용해 보초와 같은 값이 있는지를 확인한다
    - 같은 값을 찾으면 반복문을 종료한다
    - 보초가 있는 주소까지 확인하면 찾는 값이 없다는 뜻이다

![](https://blog.kakaocdn.net/dn/bhRdMD/btstSka9RdV/GNwCAQ7ugeDAmLJzbo9FeK/img.png)

- 시간 복잡도
    - O(n)

---

**이진 검색(Binary Search)**

- 정의
    - 데이터가 키값으로 이미 정렬(Sort)되어있다는 전제하에 요소가 오름차순 또는 내림차순으로 정렬된 배열에서 검색하는 알고리즘
- 장점
    - 선형검색보다 빠르다
- 구현 방법  
    - 배열의 길이의 중앙 즉 n/2를 중앙값으로 설정해 기준을 잡는다
    - 찾고자 하는 값이 중앙값보다 크면 오른쪽, 작으면 왼쪽에 있는 값들에서 다시 중앙 값을 설정해 검색을 할 것이다
    - 찾고자 하는 값을 찾을때 까지 위의 방법을 반복한다
    - 이때 찾고자 하는 값을 찾지 못했는데 위의 과정을 더이상 하지 못 할 경우 배열안에 값이 없는것이다

![](https://blog.kakaocdn.net/dn/cFYJky/btstRQVHNE0/i8av3iYdAkItG1BnwInih0/img.png)

- 시간 복잡도
    - O(logN)

---

**bsearch 함수**

- bsearch란?
    - 특정 배열안의 값을 찾고자 할 때, 이진 탐색의 방법으로 빠르게 찾아주는 함수
    - 단 이진탐색 특성상 배열은 반드시 정렬되어 있어야 한다
- 자료형 bsearch (const void * key, const void* base, size_t nel, size_t width, 자료형(*compare)(const void*, const* voide)
    - bsearch : 함수명
    - stdlib.h :포함 헤더
    - 파라미터
        - key : 찾을 값의 주소
        - *base: 찾을 대상이 되는 배열
        - nel: 배열의 길이(개수)
        - width: 배열 한 개의 크기 (sizeof(자료형))
        - 자료형(*compare)(const void*, const* voide): 비교를 수행할 함수의 포인터(함수의 리턴값이 양수일 경우 오른쪽 , 음수일 경우 왼쪽을 탐색)

---

**함수 포인터**

- 정의 
    - 함수의 시작 주소를 가르키는 포인터
    - 함수의 시작 주소에 들어가기 앞서 인수들의 목록과 리턴 형식(주소) 정보를 스택에 저장한다
- 선언
    - 리턴타입(* 함수 포인터 이름)(인수 목록)
    - int Func(int a) => 포인터: int(*funcPtr)(int)
- 사용 방법
    - 대입&호출
        - 대입
            - funcPtr = Func; (괄호없이 단독으로 사용된 함수명은 함수의 시작 번지를 나타내는 포인터 상수)
        - 호출
            - 원칙적으로 (*funcPtr)(2);
            - 하지만 컴파일러는 funcPtr(2); 도 동작한다
        - 인자가 잘못 들어가거나 리턴 형식을 잘못된 타입으로 받으면 컴파일 에러가 난다
    - 하나의 고유한 타입인 함수 포인터
        - 원형이 다른 함수 포인터끼리 직접 대입, 복사가 불가능 하다
            - int(*funcPtr1)(int), double(*funcPtr2)(float);
            - funcPtr1 = funcPtr2; //에러
        - 캐스팅 가능
            - int(*funcPtr1)(int), double(*funcPtr2)(float);
            - funcPtr1 = (int(*)(int))funcPtr2;
    - 응용
        - 함수 포인터 배열
            - int(*funcPtrArr[MAX_FUNC_NUM])(int); //함수 포인터 변수명 다음에 배열 크기 선언
            - funcPtrArr[0] = funcPtr1;
        - 함수 포인터의 포인터
            - int(**funcPPtr)(int); //일단 이건데 불편, 위에도 마찬가지
            - typedef int(*FUNCPTR)(int); //함수 포인터 타입을 typedef로 정의하고(정의 형식 주의)
            - FUNCPTR* funcPPtr; //이렇게나
            - FUNCPTR funcPtr[MAX_FUNC_NUM]; //이렇게 사용하는 것이 가독성이 높다.
- 의미
    - 함수를 변수로 사용이 가능하다
        - 하나의 함수 포인터만 가지고도 조건에 따라 다른 함수를 실행할 수 있다
        - 함수를 인자로 넘길 수 있다
        - 배열이나 구조체를 사용하여 전체 함수 그룹을 변경하는 것도 가능하다
    - 사용하기 좋은 경우
        - 조건에 따라 선택해야 할 함수가 두개 이상인 경우(함수 포인터 배열)
        - 함수 선택 분기와 실제 호출 시점이 다른 경우(미리 선택한 뒤 변수에 저장된 함수를 바로 호출)
        - 호출할 함수가 외부 모듈(DLL)에 있는 경우(동적 연결하려면 함수 포인터 사용)
- 클래스 맴버 함수의 함수 포인터
    - 클래스 내부에 메소드, 맴버 함수를  함수 포인터로 사용가능
    - 기존 함수들은 정적 함수로, 소속이나 사용 인스턴스와 무관하게 사용됨
    - 클래스의 맴버 함수들은 class이름을 네임스페이스로(Class::Function();) 인스턴스에 의존적으로(this->Function();) 사용되므로 차이가 있다
    - 실제 코드로 보는 일반/맴버함수 포인터의 차이점과 사용방법 예시
		```C++
		class World  
            {  
             public:  
               void Close() {}  
               static void Open() {}  
            };  
              
            void foo(){}  
            int main()  
            {  
               //대입  
               void(*fPtr1)() = &foo;            //일반 함수 포인터  
               void(*fPtr2)() = &World::Open;    //클래스 멤버 함수 포인터.   
               //클래스의 네임스페이스 설정이 안되어 있으나 static이므로 접근 가능  
               void(*fPtr3)() = &World::Close;   //함수 포인터 소속 불명.  
               void(World::*fPtr4)() = &World::Close; //함수의 소속을 명시하면 OK  
              
               //호출  
               fPtr4();                          
               //하지만 인스턴스에 바인딩 되지 않dm면 에러  
               World earth;   
               earth.fPtr4();                   
               //earth 내부의 멤버함수 fptr4를 찾기때문에 불가능  
               (earth.*fPtr4)();                
               //원칙적 사용방법 이렇게 쓰도록 한다.  
            }
            ```
    - 결론
        - 맴버함수를 클래스 외부에서 함수 포인터로 선언및 사용할 때 타입에 클래스 소속을 명시해서 써야한다
        - 맴버함수 호출할 때 인스턴스를 탐조해서 호출해야한다
- std::function
    - 일반 함수 포인터의 문제
        - 반환값이 명시적으로 (암시적 형변환 불가) 같은 타입이 아니면 컴파일 에러
        - 오로지 함수만 호환이 가능(functor, 맴버함수 포인터, 람다함수, bind 반환값등 안됨)
    - std::function 장점
        - 반환값이 암시적 형변환 간으한 타입이면 대입 가능
        - static 함수 포인터 ㅁ라고도 functor, 맴버함수 포인터, 람다함수, bind 반환값등 다 가능
        - 유연한 사용이 가능하다( 특히 인자로 함수를 받는 경우 다양한 활용이 가능)
- 함수 객체(funcotr)
    - 객체를 함수처럼 사용하는 것
        - 객체의 식별자를 함수 이름처럼 () 연산자를 오버로딩
        - 알고리즘 함수에서 많이 사용됨
    - 함수 포인터와의 차이
        - 맴버변수, 맴버함수를 가질 수 있다
        - 템플릿 클래스로 범용적으로 사용 가능